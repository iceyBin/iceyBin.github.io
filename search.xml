<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TTL和过期时间]]></title>
    <url>%2F2019%2F06%2F04%2FTTL%E5%92%8C%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[1 TTL介绍TTL全称Time-To-Live，即存活时间。在RabbitMQ中有两种TTL，分别是 Message TTL 和 Queue TTL。TTL可以通过参数设置，也可以通过 policies 策略设置 message-ttl 参数，推荐使用 policies 可以通过正则表达式为一个或者多个 queue 或者 exchange 定义TTL 2 Message TTL – TTL类型消息如果一条消息在队列中的存放时间超过了设置的TTL超时时间 （即在TTL设置的时间内没有消费者消费该消息），则该消息就会被认为已经”死了”，broker不会将”死了”的消息再推送给消费者，并且将会移除这些消息。消息超时时间必须是一个非负整数(&gt;=0)，单位是：毫秒 定义消息的TTL分为两种方式： 在队列中定义以及在消息中定义 在队列中定义，设置的TTL值只对当前队列的消费者有效 通过 channel.queueDeclare 方法，其最后一个参数 arguments 中添加 x-message-ttl 字段，其值设置为具体的超时时间即可。例如，设置消息超时时间为3s，则部分代码如下： Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(); arguments.put(&quot;x-message-ttl&quot;, 3000); channel.queueDeclare(queueName, true, false, false, arguments); 使用 policies 设置时，会选择 apply-to=queues，因此也属于该种方式 在消息中定义，设置的TTL值对该消息的所有的消费者都有效 也可以通过生产者调用 basic.publish 方法，设置 AMQP.BasicProperties 参数的 expiration 属性。例如： AMQP.BasicProperties basicProperties = new AMQP.BasicProperties() .builder() .expiration(&quot;3000&quot;) .build(); channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, basicProperties, message.getBytes()); 使用TTL时，你可能有些地方需要注意 发送设置了TTL的消息到队列中时，如果此时队列中已经有了其他设置了TTL的消息，有可能会出现队列中已经过期的消息在未过期消息的后面。这种情况下该已过期的消息不会被移除，只有当其前面的消息过期或者被消费者消费掉，该过期消息到达队列头部时才会被丢弃(或者放入”死信”队列)。并且，该已过期的消息在未被移除之前，其占用的系统资源并不会释放，该消息仍然会被计入到一些统计数据中(eg: 队列中总消息数目)。 设置TTL的消息会存在一种情况：已经被broker写入socket向消费者传送，但是在到达消费者之前，过期了（这种情况下，笔者也不知消息将会怎样？） 当使用 policy 设置TTL时，建议有消费者实时在线消费消息，以确保过期的消息能够尽快的被丢弃 考虑到上述行为，当需要删除消息释放资源的时候，设置了TTL的队列queue TTL应该考虑使用 3 Queue TTL – TTL类型队列TTL不仅能设置到队列中的消息上，还能设置到队列上。设置到队列上表示的意义是：在该队列自动删除之前还能存留的时间，单位是：毫秒，必须是正整数(&gt;0), ，设置了TTL的队列，当没有消费者后，等待超时时间后就会被删除，跟队列的 auto-delete 属性无关。 使用队列属性参数定义。 如下，定义一个TTL为5s的队列： Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(); arguments.put(&quot;x-expires&quot;, 5000); // 设置队列过期时间 channel.queueDeclare(QUEUE_NAME, true, false, false, arguments); 当该队列没有消费者后，等待5s就会被删除，即使 autoDelte 参数为false 使用 policy 定义 设置 policy 策略的 expires 参数，可以达到和 x-expires 一样的效果，更推荐使用 policy 定义。如： rabbitmqctl set_policy expiry &quot;.*&quot; &apos;{&quot;expires&quot;:5000}&apos; --apply-to queues 语法格式：rabbitmqctl set_policy &lt;policy名称&gt; &lt;JSON格式参数&gt; –apply-to [queues|exchanges]。除了使用命令行，也可以在WEB UI上直接定义设置 policy]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Topic交换器]]></title>
    <url>%2F2019%2F06%2F03%2FTopic%E4%BA%A4%E6%8D%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上次文章说到 Fanout交换器，有兴趣的可以参考：Fanout交换器 1 应用场景当需要“分类”推送消息的时候，就会用到 topic 类型的交换器。例如：推送日志信息，需要将系统日志和普通日志分类推送给不同的队列；当然使用前面说到的 direct 类型交换器和 fanout交换器也可以实现，但是比较麻烦，这种场景下，topic 类型交换器将是你最好的选择。 2 Topic交换器 topic 交换器允许使用带有”通配符”的 RoutingKey 将队列和broker绑定在一起，支持的通配符有两种：* 和 # * 匹配一个单词，以 . 为分割标记。例如： *.rabbit 可以代表 one.rabbit 、two.rabbit等等 # 匹配一个或者多个单词 2.1 生产者推送消息// 创建交换器：auto-delete=false durable=false channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC, true); // 发送消息 String message = &quot;hello topic exchange&quot;; String routingKey = &quot;TOPIC.RK.001&quot;; channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes()); 生产者推送消息到broker，可以看到使用的 RoutingKey 是 TOPIC.RK.001 2.2 消费者消费消息，这里定义两个消费者 Recv1 和 Recv2Recv1.java 部分代码如下： // 创建交换器 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC, true); // 创建一个私有的临时的队列 exclusive=true auto-delete=true durable=false String queueName = channel.queueDeclare().getQueue(); // 绑定队列和broker channel.queueBind(queueName, EXCHANGE_NAME, &quot;TOPIC.*.*&quot;); Recv2.java 部分代码如下： // 创建交换器 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC, true); // 创建一个私有的临时的队列 String queueName = channel.queueDeclare().getQueue(); // 绑定队列和broker channel.queueBind(queueName, EXCHANGE_NAME, &quot;TOPIC.#&quot;); 以上可以看到，Recv1.java 中使用的 RoutingKey 是 TOPIC.*.*；而 Recv2.java 中使用的 RoutingKey 是 TOPIC.#。此时，当生产者程序启动向broker推送消息，则 Recv1 和 Recv2 都会接收到消息 如果生产者的 RoutingKey 换成 TOPIC.001 则 只有 Recv2 能接收到消息 如果生产者的 RoutingKey 换成 RK.001 则两者都不会接收到消息 3 总结 topic 交换器支持通配符匹配，支持的通配符有 * 和 # 当精准匹配的时候相当于 direcr 交换器 当模糊匹配的时候相当于 fanout 交换器]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fanout交换器]]></title>
    <url>%2F2019%2F05%2F27%2FFanout%E4%BA%A4%E6%8D%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1 知识回顾通过之前 direct 交换器的学习，我们已经对rabbitMQ消息传递机制有了一定的了解，可以总结为以下几点： 生产者是生产并发送消息的应用程序 队列是消息的缓冲区，用来存放消息 消费者是接收并消费消息的应用程序 我们知道，broker是生产者和消费者之前的”桥梁”，接收生产者消息并将消息发送给消费者。那么，应该发给那些消费者，是指定的消费者还是全部的消费者呢？这就取决于 exchange 的类型，一共四种类型：direct，headers，fanout，topic，其中 headers 跟 direct 很类似，基本不再使用。 这里我们将会说到 fanout 交换器 2 应用场景生产者发送的消息到broker，所有绑定到改broker的队列对应的消费者都可以接收到消息，类似于”广播”通知模式。例如注册操作。 一般情况下，用户注册后都会进行一系列的业务操作，比如站内信通知，发送积分，甚至活动期间发送奖励等。这时，就需要当用户注册后，所有关注 “注册” 的业务都需要收到 “用户注册” 这个消息，并进行相应的逻辑处理，这时就可以用 fanout 类型交换器实现消息的推送通知。 3 进入正题 3.1 生产者发送消息// 定义Fanout类型的交换器 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, true); // 发送消息 String message = &quot;hello world&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(String.format(&quot;推送消息[%s]成功&quot;, message)); 我们可以看到 basicPublish 方法的第二个参数 routinhKey 为 &quot;&quot;。这里无论是否使用空字符串，效果都是一样的，因此直接使用 &quot;&quot; 即可 3.2 消费者接收消息// 创建交换器 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, true); // 创建一个私有的临时的队列 exclusive=true auto-delete=true durable=false String queueName = channel.queueDeclare().getQueue(); // 绑定队列到交换器 channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;); // 消费消息 channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; {}); 当然，你完全可以像之前那样定义一个持久性有固定名称的队列。但是，如果有需要 （比如每次连接到broker都需要一个全新的队列），这时就可以使用方法 channel.queueDeclare() 创建一个随机的队列，该队列性质：exclusive=true，auto-delete=true，durable=false 这里还要说下 queueBind() 方法，可以看到该方法的第三个参数 routingKey 也是 &quot;&quot;。 就像我们之前说的那样，这里也是一样，无论是否使用空字符串效果都是一样的，因为 fanout 类型的交换器会把到达broker的消息发送给所有绑定到该交换器上的 queue 中 (无论使用的routingKey是否是””)]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Direct类型交换器-生产者confirm模式]]></title>
    <url>%2F2019%2F05%2F26%2FDirect%E7%B1%BB%E5%9E%8B%E4%BA%A4%E6%8D%A2%E5%99%A8-%E7%94%9F%E4%BA%A7%E8%80%85confirm%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Direct类型交换器-生产者confirm模式上篇文章简单入门了Direct交换器，如有需要请查看 Direct类型交换器-基础使用 1 prefetch属性的设置问题：分布式环境中，每个消费者会有多个实例同时存在，这时对应的生产者推送的消息，该消费者如何消费呢？是均匀的分发，还是根据消费能力，能者多劳呢？ 答案是：均匀分发消费。如果一个消费者有多个实例，那么到达这个消费者的消息会被broker进行均匀的分发消费，这是broker默认的机制。当然，实际应用中，会有很多的条件导致该消费者的多个实例的消费能力不同 (比如机器配置不同、网络带宽影响等等)，这时我们理想的情况是”能者多劳”。这时，我们只需要调用 basicQos 方法这时 prefetch = 1 即可 ，即可达到理想效果 (这也是springBoot集成rabbitMQ的默认配置)。这样设置的情况下，如果某个消费者实例消费能力比较弱，在收到 ack 确认之前，broker不会再分发消息到该实例 int prefetchCount = 1; channel.basicQos(prefetchCount); 2 生产者confirm模式上篇文章说到，消费者可以采用手动 ack 确认的模式尽量的防止消息的丢失。但是，这样真的就达到目的了吗？当然不是，试想，如果生产者的消息根本就没有到达broker呢？要解决这个问题，就需要用到生产者confirm模式 2.1 设置channel为confirm模式// 将信道设置为confirm模式 channel.confirmSelect(); broker如果接收到消息会进行回调，生产者有两种方式可以进行消息发送成功以及失败的后续处理，分别是手动逐条确认和异步监听确认 2.2 手动逐条确认每次发送消息后进行确认 if (channel.waitForConfirms()) { System.out.println(String.format(&quot;推送消息[%s]成功&quot;, message)); } else { System.out.println(String.format(&quot;推送消息[%s]失败，消息丢失&quot;, message)); } 2.3 异步监听确认还可以通过添加监听进行异步确认。改方式的优点是：异步、可以批量确认 channel.addConfirmListener(new ConfirmListener() { @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException { System.out.println(String.format(&quot;MQ接收消息[%s:%b]成功&quot;, deliveryTag, multiple)); } @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException { System.out.println(String.format(&quot;MQ接收消息[%s:%b]失败，消息丢失&quot;, deliveryTag, multiple)); } }); 我们来看下异步确认程序的执行结果： MQ接收消息[2:true]成功 MQ接收消息[3:false]成功 MQ接收消息[4:false]成功 MQ接收消息[5:false]成功 MQ接收消息[6:false]成功 从执行结果中可以看出，是否批量确认在于返回的multiple的参数，此参数为bool值。有时 multiple 返回的是 true，这说明批量确认了 响应的 deliveryTag 标识的该条消息之前的所有消息，返回 false 表示单条确认对应的 deliveryTag 这条消息。可以看到使用这种模式 deliveryTag 会从1依次递增标识消息。 3 总结 一般情况下消费者会使用 channel.basicQos(int prefetch) 方法设置prefetch为1，达到同个消费者多个实例之间”能者多劳”的目的 为了尽量的保证避免消息的丢失，应该同时采用消费者手动ack和生产者confirm模式 虽然rabbitMQ还有事务机制保证生产者发送的消息一定会到达broker，但是本身性能受损比较严重，不建议使用，有兴趣的可以另行查找资料 4 扩展Direct 类型交换器和队列的绑定是通过 RoutingKey 来完成的，RoutingKey 和 queue 的关系不只是一对一的关系，还可以是一对多，多对一关系。注：以下情况每个队列对应一个消费者 一对多模型，一个 RoutingKey 可以绑定多个不同的 queue （假设名称为q1，q2，q3） 到broker上，q1，q2，q3对应的消费者分别为 c1、c2和c3。这种情况下，如果生产者通过该 RoutingKey 发送消息，则c1、c2和c3都会收到相同的消息 多对一模型，多个不同的 RoutingKey （假设名称为rk1，rk2，rk3） 可以绑定同一个 queue 到broker上，该队列对应的消费者是 c1 。这种情况下，如果生产者通过rk1，rk2，rk3中的任意一个发送消息，则 c1 都会接收到消息]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Direct类型交换器-基础使用]]></title>
    <url>%2F2019%2F05%2F26%2FDirect%E7%B1%BB%E5%9E%8B%E4%BA%A4%E6%8D%A2%E5%99%A8-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Direct交换器-基础使用1 建立连接，获取信道MQUtil.java // 建立到代理服务器的连接 public static Connection getConnection(String vhost) throws Exception { ConnectionFactory connectionFactory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;admin&quot;); if (!StringUtils.isEmpty(vhost)) { connectionFactory.setVirtualHost(vhost); } return connectionFactory.newConnection(); } 后续的动作都是用channel来完成，使用try-resource包装，使得connection和channel可以自动关闭 try (Connection connection = MQUtil.getConnection(); Channel channel = connection.createChannel()) {...} 2 生产者推送消息生产者推送消息到MQ只需要RoutingKey和Exchange即可： // 定义交换器. durable标识是否持久化 channel.exchangeDeclare(exchange, BuiltinExchangeType.DIRECT, durable); // 推送消息 channel.basicPublish(exchange, routingKey, props, body); 方法参数意义： exchange: 使用的交换器名称，如果使用默认的交换器，此处使用空字符串 &quot;&quot; routingKey: 消息指定的RoutingKey，MQ会通过该RoutingKey将消息分发到通过该值绑定的队列中 props: 该参数的类型是 BasicProperties 主要用来设置消息的一些信息，如contentType、headers等。 MessageProperties 是获取 BasicProperties 对象的一个工具类，只要用来获取不同类型的信息 body: 消息本身内容，类型是 byte[] 3 消费者消费消息3.1 定义交换器和队列消费消息时不需要将 Connection 和 Channel 进行 try-resource 封装，因为消费者需要循环的监控接收消息，因此不能关闭信道和连接 // 定义交换器 channel.exchangeDeclare(exchange, type, durable); // 定义队列 channel.queueDeclare(quueName, true, false, false, null); // 将队列通过RoutingKey绑定到交换器上 channel.queueBind(queue, exchange, routingKey); 这里主要看下 queueDeclare 方法，该方法的定义如下： Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments) throws IOException; queue: 队列名称 durable: 是否持久化 exclusive: 是否排他，如果设置为true，则表示只能用于创建其的连接中，不能用于另外的连接(例如：如果有两个客户端同时都是新创建连接，然后定义相同的一个 exclusive 属性为true的队列，则只有其中的一个能成功启动，另外一个启动会报错)。 并且，当连接关闭或者断开的时候，该队列会被自动删除 (即使定义的队列是持久化的) autoDelete: 是否自动删除。 如果设置为true，则当没有消费者使用这个队列的时候，这个队列会被自动删除 3.2 消费消息// 消费者成功接收到消息，消费回调函数 DeliverCallback deliverCallback = (consumerTag, message) -&gt; { String receiveMsg = new String(message.getBody()); // 手动确认消息的接收 channel.basicAck(message.getEnvelope().getDeliveryTag(), false); }; // 消费消息 channel.basicConsume(QUEUE_NAME, deliverCallback, (consumerTag) -&gt; { System.err.println(String.format(&quot;系统异常，消费者[%s]不能正常消费消息&quot;, consumerTag)); }); 需要注意的是 basicAck 方法的第二个参数，这个参数标识是否要批量确认。如果设置为 true 则会批量确认所有该channel中已经到达MQ服务器的消息；如果设置为 false，则只确认指定的deliverTag对应的消息。 再来看下消费消息的函数 basicConsume 定义如下： String basicConsume(String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) throws IOException; 该方法是一个无限循环阻塞方法，会循环获取绑定的队列中的消息 queue：队列名称。 指定消费者从哪个队列中消费消息 deliverCallback: 消费者成功接收MQ推送的消息的回调函数，主要在该函数中进行消息的处理以及手动ack。该函数有个重载，多了一个 autoAck 参数，标识是否自动确认消息的接收。如果设置为 true 则当消费者正常接收到消息就会向MQ自动确认，MQ就会将该消息从消息队列中删除(即使消息后续没有被成功消费)， 默认false，一般情况下都会使用默认false。 如果设置为 false 就需要在 deliverCallback 回调函数中进行手动确认。 cancelCallback: 当MQ服务出现问题，导致不能正常消费消息 (比如：队列被删除等)，则会调用该回调函数。此外，消费者也可以调用 channel.basicAck 手动取消该消费者 4 总结 生产者推送消息只需要 RoutingKey 和 Exchange 消费者建议手动 ack 确认，尽量保证消息不丢失 笔者建议生产者和消费者双方都需要进行创建队列的工作，因为不确定哪一方先启动 如果想要消息的持久化，必须保证交换器持久化、队列持久化]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识RabbitMQ]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%88%9D%E8%AF%86RabbitMQ%2F</url>
    <content type="text"></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>

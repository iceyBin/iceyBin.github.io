{"meta":{"title":"Ice's Blog","subtitle":"If you can do what you do best and be happy, u are the further along in life than most people","description":"Coding, Travelling, Learning and Enjoying","author":"Ice","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2019-05-27T00:40:32.000Z","updated":"2019-05-27T03:18:38.352Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-27T00:40:08.000Z","updated":"2019-05-27T03:19:42.056Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"4，Fanout交换器","slug":"4-Fanout交换器","date":"2019-05-27T09:41:47.000Z","updated":"2019-05-28T10:42:18.728Z","comments":true,"path":"2019/05/27/4-Fanout交换器/","link":"","permalink":"http://yoursite.com/2019/05/27/4-Fanout交换器/","excerpt":"","text":"","categories":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/categories/中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"}]},{"title":"3, Direct类型交换器-生产者confirm模式","slug":"3-Direct类型交换器-生产者confirm模式","date":"2019-05-26T09:29:29.000Z","updated":"2019-05-30T09:36:26.970Z","comments":true,"path":"2019/05/26/3-Direct类型交换器-生产者confirm模式/","link":"","permalink":"http://yoursite.com/2019/05/26/3-Direct类型交换器-生产者confirm模式/","excerpt":"","text":"Direct类型交换器-生产者confirm模式上篇文章简单入门了Direct交换器，如有需要请查看 Direct类型交换器-基础使用 1 prefetch属性的设置问题：分布式环境中，每个消费者会有多个实例同时存在，这时对应的生产者推送的消息，该消费者如何消费呢？是均匀的分发，还是根据消费能力，能者多劳呢？ 答案是：均匀分发消费。如果一个消费者有多个实例，那么到达这个消费者的消息会被broker进行均匀的分发消费，这是broker默认的机制。当然，实际应用中，会有很多的条件导致该消费者的多个实例的消费能力不同 (比如机器配置不同、网络带宽影响等等)，这时我们理想的情况是”能者多劳”。这时，我们只需要调用 basicQos 方法这时 prefetch = 1 即可 ，即可达到理想效果 (这也是springBoot集成rabbitMQ的默认配置)。这样设置的情况下，如果某个消费者实例消费能力比较弱，在收到 ack 确认之前，broker不会再分发消息到该实例 int prefetchCount = 1; channel.basicQos(prefetchCount); 2 生产者confirm模式上篇文章说到，消费者可以采用手动 ack 确认的模式尽量的防止消息的丢失。但是，这样真的就达到目的了吗？当然不是，试想，如果生产者的消息根本就没有到达broker呢？要解决这个问题，就需要用到生产者confirm模式 2.1 设置channel为confirm模式// 将信道设置为confirm模式 channel.confirmSelect(); broker如果接收到消息会进行回调，生产者有两种方式可以进行消息发送成功以及失败的后续处理，分别是手动逐条确认和异步监听确认 2.2 手动逐条确认每次发送消息后进行确认 if (channel.waitForConfirms()) { System.out.println(String.format(&quot;推送消息[%s]成功&quot;, message)); } else { System.out.println(String.format(&quot;推送消息[%s]失败，消息丢失&quot;, message)); } 2.3 异步监听确认还可以通过添加监听进行异步确认。改方式的优点是：异步、可以批量确认 channel.addConfirmListener(new ConfirmListener() { @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException { System.out.println(String.format(&quot;MQ接收消息[%s:%b]成功&quot;, deliveryTag, multiple)); } @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException { System.out.println(String.format(&quot;MQ接收消息[%s:%b]失败，消息丢失&quot;, deliveryTag, multiple)); } }); 我们来看下异步确认程序的执行结果： MQ接收消息[2:true]成功 MQ接收消息[3:false]成功 MQ接收消息[4:false]成功 MQ接收消息[5:false]成功 MQ接收消息[6:false]成功 从执行结果中可以看出，是否批量确认在于返回的multiple的参数，此参数为bool值。有时 multiple 返回的是 true，这说明批量确认了 响应的 deliveryTag 标识的该条消息之前的所有消息，返回 false 表示单条确认对应的 deliveryTag 这条消息。可以看到使用这种模式 deliveryTag 会从1依次递增标识消息。 3 总结 一般情况下消费者会使用 channel.basicQos(int prefetch) 方法设置prefetch为1，达到同个消费者多个实例之间”能者多劳”的目的 为了尽量的保证避免消息的丢失，应该同时采用消费者手动ack和生产者confirm模式 虽然rabbitMQ还有事务机制保证生产者发送的消息一定会到达broker，但是本身性能受损比较严重，不建议使用，有兴趣的可以另行查找资料","categories":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/categories/中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"}]},{"title":"2, Direct类型交换器-基础使用","slug":"2-Direct类型交换器-基础使用","date":"2019-05-26T08:13:49.000Z","updated":"2019-05-30T07:04:46.689Z","comments":true,"path":"2019/05/26/2-Direct类型交换器-基础使用/","link":"","permalink":"http://yoursite.com/2019/05/26/2-Direct类型交换器-基础使用/","excerpt":"","text":"Direct交换器-基础使用1 建立连接，获取信道MQUtil.java // 建立到代理服务器的连接 public static Connection getConnection(String vhost) throws Exception { ConnectionFactory connectionFactory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;admin&quot;); if (!StringUtils.isEmpty(vhost)) { connectionFactory.setVirtualHost(vhost); } return connectionFactory.newConnection(); } 后续的动作都是用channel来完成，使用try-resource包装，使得connection和channel可以自动关闭 try (Connection connection = MQUtil.getConnection(); Channel channel = connection.createChannel()) {...} 2 生产者推送消息生产者推送消息到MQ只需要RoutingKey和Exchange即可： // 定义交换器. durable标识是否持久化 channel.exchangeDeclare(exchange, BuiltinExchangeType.DIRECT, durable); // 推送消息 channel.basicPublish(exchange, routingKey, props, body); 方法参数意义： exchange: 使用的交换器名称，如果使用默认的交换器，此处使用空字符串 &quot;&quot; routingKey: 消息指定的RoutingKey，MQ会通过该RoutingKey将消息分发到通过该值绑定的队列中 props: 该参数的类型是 BasicProperties 主要用来设置消息的一些信息，如contentType、headers等。 MessageProperties 是获取 BasicProperties 对象的一个工具类，只要用来获取不同类型的信息 body: 消息本身内容，类型是 byte[] 3 消费者消费消息3.1 定义交换器和队列消费消息时不需要将 Connection 和 Channel 进行 try-resource 封装，因为消费者需要循环的监控接收消息，因此不能关闭信道和连接 // 定义交换器 channel.exchangeDeclare(exchange, type, durable); // 定义队列 channel.queueDeclare(quueName, true, false, false, null); // 将队列通过RoutingKey绑定到交换器上 channel.queueBind(queue, exchange, routingKey); 这里主要看下 queueDeclare 方法，该方法的定义如下： Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments) throws IOException; queue: 队列名称 durable: 是否持久化 exclusive: 是否排他，如果设置为true，则表示只能用于创建其的连接中，不能用于另外的连接(例如：如果有两个客户端同时都是新创建连接，然后定义相同的一个 exclusive 属性为true的队列，则只有其中的一个能成功启动，另外一个启动会报错)。 并且，当连接关闭或者断开的时候，该队列会被自动删除 (即使定义的队列是持久化的) autoDelete: 是否自动删除。 如果设置为true，则当没有消费者使用这个队列的时候，这个队列会被自动删除 3.2 消费消息// 消费者成功接收到消息，消费回调函数 DeliverCallback deliverCallback = (consumerTag, message) -&gt; { String receiveMsg = new String(message.getBody()); // 手动确认消息的接收 channel.basicAck(message.getEnvelope().getDeliveryTag(), false); }; // 消费消息 channel.basicConsume(QUEUE_NAME, deliverCallback, (consumerTag) -&gt; { System.err.println(String.format(&quot;系统异常，消费者[%s]不能正常消费消息&quot;, consumerTag)); }); 需要注意的是 basicAck 方法的第二个参数，这个参数标识是否要批量确认。如果设置为 true 则会批量确认所有该channel中已经到达MQ服务器的消息；如果设置为 false，则只确认指定的deliverTag对应的消息。 再来看下消费消息的函数 basicConsume 定义如下： String basicConsume(String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback) throws IOException; 该方法是一个无限循环阻塞方法，会循环获取绑定的队列中的消息 queue：队列名称。 指定消费者从哪个队列中消费消息 deliverCallback: 消费者成功接收MQ推送的消息的回调函数，主要在该函数中进行消息的处理以及手动ack。该函数有个重载，多了一个 autoAck 参数，标识是否自动确认消息的接收。如果设置为 true 则当消费者正常接收到消息就会向MQ自动确认，MQ就会将该消息从消息队列中删除(即使消息后续没有被成功消费)， 默认false，一般情况下都会使用默认false。 如果设置为 false 就需要在 deliverCallback 回调函数中进行手动确认。 cancelCallback: 当MQ服务出现问题，导致不能正常消费消息 (比如：队列被删除等)，则会调用该回调函数。此外，消费者也可以调用 channel.basicAck 手动取消该消费者 4 总结 生产者推送消息只需要 RoutingKey 和 Exchange 消费者建议手动 ack 确认，尽量保证消息不丢失 笔者建议生产者和消费者双方都需要进行创建队列的工作，因为不确定哪一方先启动 如果想要消息的持久化，必须保证交换器持久化、队列持久化","categories":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/categories/中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"}]},{"title":"1, 初识RabbitMQ","slug":"1-初识RabbitMQ","date":"2019-05-26T07:13:49.000Z","updated":"2019-05-28T10:33:43.625Z","comments":true,"path":"2019/05/26/1-初识RabbitMQ/","link":"","permalink":"http://yoursite.com/2019/05/26/1-初识RabbitMQ/","excerpt":"","text":"","categories":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/categories/中间件/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-23T10:45:29.153Z","updated":"2019-05-23T10:45:29.154Z","comments":true,"path":"2019/05/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}